//! Contains the CRS and the functionality a trusted party can use to generate it.
//!
//! The Common Reference String (CRS) for Groth-Sahai consists of a commitment keypair `(u, v)` and
//! the bilinear group generators `(g1, g2, gt)`.
//!
//! - As per [[GSW '10]](https://www.iacr.org/archive/pkc2010/60560179/60560179.pdf), the CRS
//! should either be generated by a trusted party or through some other form of trusted
//! computation as a binding key for a real system.
//! - The committment keys `u` and `v` should be computationally indistinguishable
//! under the SXDH assumption as to whethere they were instantiated as a:
//!    1) Perfect soundness string (i.e. perfectly binding), or
//!    2) Composable witness-indistinguishability string (i.e. perfectly hiding)

use crate::data_structures::*;

use ark_std::rand::{CryptoRng, Rng};
use ark_ff::{Zero, UniformRand};
use ark_ec::{AffineCurve, ProjectiveCurve, PairingEngine};

use nalgebra::Vector2;

/// An abstract trait for denoting how to generate a CRS
pub trait AbstractCrs<E: PairingEngine> {

    /// Generates the keys `u` for committing `G1` and `Fr` to
    /// [`B1`](crate::data_structures::B1) and `v` for committing `G2` and `Fr` to
    /// [`B2`](crate::data_structures::B2).
    fn generate_crs<R>(rng: &mut R) -> Self where R: Rng + CryptoRng;
}

/// Contains the commitment keys and bilinear group generators
pub struct CRS<E: PairingEngine>
{
    pub u: Vector2<Com1<E>>,
    pub v: Vector2<Com2<E>>,
    pub g1_gen: E::G1Affine,
    pub g2_gen: E::G2Affine,
    pub gt_gen: E::Fqk,
}

impl<E: PairingEngine> CRS<E> {

    // Returns intermediate "second" values that are used to construct un-blinded (i.e. binding) committment keys
    #[inline(always)]
    #[allow(unused_variables)]
    fn prepare_real_binding_key(
        g1_gen: E::G1Projective,
        g2_gen: E::G2Projective,
        q1: E::G1Projective,
        t1: E::Fr,
        q2: E::G2Projective,
        t2: E::Fr,
    ) -> (E::G1Projective, E::G2Projective)
    {
        // NOTE: v1 and v2 should be the only difference between a blinding and a hiding key
        let v1 = q1.into_affine().mul(t1) - E::G1Projective::zero();
        let v2 = q2.into_affine().mul(t2) - E::G2Projective::zero();
        (v1, v2)
    }

    // Returns intermediate "second" values that are used to construct blinded (i.e. hiding) committment keys
    #[inline(always)]
    #[allow(dead_code)]
    fn prepare_simulated_hinding_key(
        g1_gen: E::G1Projective,
        g2_gen: E::G2Projective,
        q1: E::G1Projective,
        t1: E::Fr,
        q2: E::G2Projective,
        t2: E::Fr,
    ) -> (E::G1Projective, E::G2Projective)
    {
        // NOTE: v1 and v2 should be the only difference between a blinding and a hiding key
        let v1 = q1.into_affine().mul(t1) - g1_gen;
        let v2 = q2.into_affine().mul(t2) - g2_gen;
        (v1, v2)
    }
}

impl<E: PairingEngine> AbstractCrs<E> for CRS<E> {

    fn generate_crs<R>(rng: &mut R) -> CRS<E>
    where
        R: Rng + CryptoRng,
    {

        // Generators for G1 and G2
        let p1 = E::G1Projective::rand(rng);
        let p2 = E::G2Projective::rand(rng);

        // Scalar intermediate values
        let a1 = E::Fr::rand(rng);
        let a2 = E::Fr::rand(rng);
        let t1 = E::Fr::rand(rng);
        let t2 = E::Fr::rand(rng);

        // Projective intermediate values
        let q1 = p1.into_affine().mul(a1);
        let q2 = p2.into_affine().mul(a2);
        let u1 = p1.into_affine().mul(t1);
        let u2 = p2.into_affine().mul(t2);

        let (v1, v2) = Self::prepare_real_binding_key(p1, p2, q1, t1, q2, t2);

        // B1 commitment key for G1 and Fr
        let u11 = Com1::<E>(p1.into_affine(), q1.into_affine());
        let u12 = Com1::<E>(u1.into_affine(), v1.into_affine());

        // B2 commitment key for G2 and Fr
        let u21 = Com2::<E>(p2.into_affine(), q2.into_affine());
        let u22 = Com2::<E>(u2.into_affine(), v2.into_affine());

        CRS::<E> {
            u: Vector2::new(u11, u12),
            v: Vector2::new(u21, u22),
            g1_gen: p1.into_affine(),
            g2_gen: p2.into_affine(),
            gt_gen: E::pairing::<E::G1Affine, E::G2Affine>(p1.into_affine(), p2.into_affine())
        }
    }
}


#[cfg(test)]
mod tests {
    use ark_bls12_381::{Bls12_381 as F};
    use ark_ff::{Zero, One};
    use ark_ec::PairingEngine;
    use ark_std::test_rng;

    use super::*;

    type G1Projective = <F as PairingEngine>::G1Projective;
    type G1Affine = <F as PairingEngine>::G1Affine;
    type G2Projective = <F as PairingEngine>::G2Projective;
    type G2Affine = <F as PairingEngine>::G2Affine;
    type GT = <F as PairingEngine>::Fqk;
    type Fr = <F as PairingEngine>::Fr;

    #[test]
    fn test_valid_generators() {

        let mut rng = test_rng();

        let crs = CRS::<F>::generate_crs(&mut rng);

        // Generator for GT is e(g1,g2)
        assert_eq!(crs.gt_gen, F::pairing::<G1Affine, G2Affine>(crs.g1_gen, crs.g2_gen));
        // Non-degeneracy of bilinear pairing will hold
        assert_ne!(crs.g1_gen, G1Affine::zero());
        assert_ne!(crs.g2_gen, G2Affine::zero());
        assert_ne!(crs.gt_gen, GT::one());
    }


    #[allow(non_snake_case)]
    #[test]
    fn test_valid_binding_CRS() {

        std::env::set_var("DETERMINISTIC_TEST_RNG", "1");
        let mut rng = test_rng();
        let mut rng2 = test_rng();

        let crs = CRS::<F>::generate_crs(&mut rng);

        // Follow the same process as necessary to prepare a binding key
        let p1 = G1Projective::rand(&mut rng2);
        let p2 = G2Projective::rand(&mut rng2);
        let a1 = Fr::rand(&mut rng2);
        let a2 = Fr::rand(&mut rng2);
        let t1 = Fr::rand(&mut rng2);
        let t2 = Fr::rand(&mut rng2);
        let q1 = p1.into_affine().mul(a1);
        let q2 = p2.into_affine().mul(a2);
        let (v1, v2) = CRS::<F>::prepare_real_binding_key(p1, p2, q1, t1, q2, t2);

        // Generated commitment keys are non-trivial
        assert_ne!(crs.u.x, Com1::zero());
        assert_ne!(crs.u.y, Com1::zero());
        assert_ne!(crs.v.x, Com2::zero());
        assert_ne!(crs.v.y, Com2::zero());

        // The chosen keys are binding (i.e. not hiding)
        assert_ne!(crs.g1_gen, G1Affine::zero());
        assert_ne!(crs.g2_gen, G2Affine::zero());
        assert_eq!(crs.u.y.1, v1.into_affine());
        assert_eq!(crs.v.y.1, v2.into_affine());
    }
}

